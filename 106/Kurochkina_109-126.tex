\lgroup 123456789
829437651\rgroup 
И обратно, дать перестановки, таблицы инверсий которых следующие:
(0 1 1 3 2 4 6), (0 1 1 3 3 4 6 7 5).
\textbf{d.} Показать, что массив инерсий a некоторой перестановки \sigma  удовлетворяет условиям: 0 \leqslant a_{k} <  k = 1, 2, ... , n. Каков массив инверсий единственной возрастающей перестановки интервала [1, n]? Тот же вопрос для единственной убывающей перестановки.
\textbf{e.} Написать алгоритм, который некоторой биекци \alpha интервала [1, n] ставит в сооьветствие ее массив инверсий a.
\textbf{f.} Пусть дана последовательность a целых чисел n, удовлетряющих условиям: 0 \leqslant a_{k} <  k = 1, 2, ... , n; показать, что существует одна и только одна перестановка \sigma интервала [1, n], таблица инверсий которого и есть a. Ответ на этот вопрос является не только свойством существования, но и алгоритмом вычисления, позволяющим получить \alpha, исходя из ее таблицы инверсий. Дать элементы обоснования этого алгоритма.
Проверить алгоритм на следующих примерах таблиц инверсий:
(0, 0, 2, 1, 3, 4, 6), (0, 1, 0, 3, 4, 2, 1), (0, 0, 0, 2, 4, 0, 5),
(0, 0, 0, 0, 0, 0, 0) и (0, 1, 2, 3, 4, 5, 6).

\textbf{24. Перебор перестановок транспозициями \textit{(i, i+1)}}

\textbf{a.} Показать, что можно располодить перестановки интервала [1, n] в последовательность \sigma_{1}, \sigma_{2}, ... , \sigma_{n!} такую, что перестановка (сигма i+1) получается из перестановки (сигма i) транспозицией образов двух последовательных чисел. Это упорядочение приводит также к тому, что первая из этих перестановок получается из последней применением в точности того же правила - \sigma_{1} есть результат композиции транспозиции (i, i+1) и перестановки \sigma_{n!}.
\textbf{b.} Рассмотрим множество E таблиц инверсий интервала [1, n], которое наделяется знакочередующимся лексикографическим порядком. Пусть a,b \in E и \alpha, \beta - соответствующие перестановки интервала [1, n]; показать, что если b является последующим элементом для a в E, то перестановка \beta получается из перемтановки \alpha транспозицией двух последовательных элементов.
\textbf{c.} Вывести из предыдущего вопроса алгоритм, реализующий вопрос \textbf{a}: этот алгоритм должен быть способен по некоторой данной перестановке вычислить транспозицию, котоую необходимо совершить, чтобы получить следующую перестановку.

\textbf{25. Принцип включения-исключения или формула решета}

Это упражнение посвящено формуле перечисления, которая обобщает формулу для мощности объединения двух множеств |A \bigcup B| = |A| + |B| - |A \cap B|. Всюду в упражнении X обозначает конечное множество, а (X_{i})_{i \in I} - семейство подмножеств X, индексированное конечным множеством интедксов I; напомним что \bigcup _{i \in \varnothing} X_{i} = \varnothing и X_{i} = X. Если Y \subset X, то через \overline{Y} обозначается дополнение Y в X и через |Y| - число элементов Y.
\textbf{a.} Доказать формулы:

|\frac{\bigcup }{i \in I} X_{i}| = \frac{\Sigma }{\varnothing \neq J \subset I} (-1)^{|J|+1 } |\frac{\cap }{i \in J} X_{i}| и двойственную

|\frac{\cap }{i \in J} X_{i}| = \frac{\Sigma }{\varnothing \neq J \subset I} (-1)^{|J|+1 } |\frac{\bigcup }{i \in I} X_{i}|.

Отсюда вывести формулу Сильвестера (называемую также формулой решета):

|\frac{\bigcap }{i \in I} \overline{X_{i}}| = \frac{\Sigma }{J \subset I} (-1)^{|J|} |\frac{\cap }{i \in J} X_{i}|

термин "решето" происходит из того факта, что для перечисления множества элементов, которые не принадлежат ни одному из X_{i}, достаточно перечислить те, которые принадлежат X_{i}, затем те, которые принадлежат X_{i} \cap X_{j}, и т.д.
\textbf{b.} Доказать аналогичные формулы, когда кардинальная функция \textit{P(X)} \rightarrow \mathbb{N}  заменяется весовой функцией \textit{p} со значениями в некоторой абелевой группе, эта функция \textit{p} определена на \textit{X} и продолжена на множество \textit{P(X)} подмножества \textit{X} в соответствии с равенством \textit{p(Y)} = \Sigma\textit{_{y \in Y} p(y)}
\textbf{c.} Использовать формулу Сильвестра для доказательства, что чисто \sigma_{n} перестановок из \textit{n} элементов без фиксированной точки дается формулой:

\sigma_{n} = \textit{n!} \lgroup 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + ... + (-1)^{\textit{n}} \frac{1}{\textit{n!}} \rgroup 

\textbf{d.} Для n \in N обозначим через \varphi (n) число целых чисел из интервала [1, n], взаимно простых с n: \varphi (n) называется функцией Эйлера и будет изучена более полно в главе IV; здесь предлагается метод вычисления \varphi (n), использующий формулу решета. Если p_{1}^{\alpha_{1}} ... p_{k}^{\alpha_{k}} — разложение на простые множители числа n, доказать, что:

\varphi (n) = n \lgroup 1 - \frac{1}{p_{1}} \rgroup ... \lgroup 1 - \frac{1}{p_{k}} \rgroup .

e. Показать, что формула Райзера для вычисления перманента (см. упражнение 21) выводится из формулы решета.

\textbf{26. Произведение многочленов, заданных массивами}

Условимся представлять многочлены массивами, индексированными, начиная с 0, в которых элемент с индексом i означает коэффициент одночлена степени i:

\textbf{\textit{type Polynome is array (Natural range <>) of Ring-Element;}}

\textbf{a.} Исходя из умножения и сложения элементов базового кольца, реализовать функцию умножения двух таких многочленов.
\textbf{b.} Предполагая, что умножение и сложение элементов базового кольца требует постоянного времени счета (какими бы ни были комбинируемые элементы), дать достаточно точную оценку времени перемножения двух многочленов в зависимости от их степеней.

\textbf{27. Возведение в степень многочленов, заданных массивами}

\textbf{a.} С предположениями предыдущего упражнения — время умножения и сложения постоянно в базовом кольце — оценить сложность алгоритма возведения в степень через последовательные перемножения.
\textbf{b.} Сохраняя те же предположения, определить время вычисления () через алгоритм дихотомического возведения в степень: сначала, если n является степенью 2, n = 2^{l}, затем, если n имеет вид 2^{l} - 1. Какой можно сделать вывод?

\textbf{28. Небольшие оптимизации для произведений многочленов}

В принципе вычисление произведения двух многочленов степеней n и m соответственно требует (n+1)(m+1) элементарных перемножений.
\textbf{a.} Пользуясь соображением симметрии, написать алгоритм, позволяющий возвести многочлен в квадрат, осуществляя приблизительно половину элементарных перемножений, которые кажутся необходимыми.
\textbf{Ь.} Найти способ, позволяющий умножать два многочлена первой степени с помощью 3 элементарных перемножений вместо 4 (конечно, при этом число элементарных сложений возрастает). Рекурсивно применить этот способ для получения эффективного алгоритма перемножения двух многочленов, чья степень имеет вид 2^{l} - 1. Выразить сложность этого алгоритма через число элементарных умножений и сложений.

\textbf{29. Высота произведения двух многочленов}

Цель этого упражнения — установить некоторые соотношения между высотой (числом ненулевых одночленов) произведения двух многочленов и высотой исходных многочленов. Запись \sharp P означает высоту многочлена.

\textbf{a.} Если даны два многочлена Р и Q с высотой р и q соответственно, какова максимальная высота произведения Р на Q? Существуют ли многочлены, позволяющие достичь этой высоты?
Ответ, полученный на этот вопрос, не удовлетворителен: действительно, оба многочлена, которые позволяют достичь теоретической границы высоты, очень специфичны, и мы вправе спросить, не является ли эта граница исключением и не является ли высота произведения двух многочленов в среднем гораздо более скромной. Последующие вопросы показывают, что даже если ограничиться степенями одного и того же многочлена, высота результата может расти очень быстро в зависимости от показателя.
\textbf{b.} Пусть Р — многочлен высоты d; показать, что \sharp P \leqslant (\frac{d+n-1}{n}).
\textbf{c.} Рассмотрим многочлен Р = \sum^{d}_{i=1} X^{F_{1+i_{n}}}, где Fj означает j-тое число Фибоначчи. Показать, что с этим многочленом граница вопроса b достигается.

\textbf{30. Представление многочленов списками}

Когда нужно обратиться к разреженным многочленам (т.е. имеющим много нулевых коэффициентов) или же к многочленам, высоту которых трудно ограничить, их обычно представляют не в виде массивов, а, скорее, в форме динамических структур типа списка. Алгоритмы, действующие с многочленами, представленными этим способом, очень специфичны и требуют тщательного изучения, если мы не хотим удесятерить их сложность. Чтобы упростить терминологию, ниже всюду будем называть несобственно разреженным многочленом всякий многочлен, представление которого является цепным списком, независимо от того, действительно ли этот многочлен разрежен или нет (в целом не меняя представления многочлена по ходу вычислений, даже если окажется, что оно не самое оптимальное).
Описать на языке Ада структуру данных, допускающих представление разреженных многочленов списками. Какие исходные данные априори необходимы в списках, чтобы выполнять действия над этими многочленами? Ввести эти исходные данные и обсудить выгоды и неудобства выбранных структур.

\textbf{31. Сложение многочленов, представленных списками}

Написать алгоритм сложения двух разреженных многочленов, используя только исходные данные, описанные в предыдущем упражнении. Оценить сложность этого алгоритма.

\textbf{32. Умножение многочленов, представленных списками}

Написать алгоритм умножения двух многочленов, представленных списками. Рассмотреть для этого сложность различных методов в зависимости от сложности алгоритма сложения, введенного в упражнении 31.

\textbf{33. Действия с формальными рядами}

\textbf{a.} Принцип вычисления квадрата многочлена, показанный в упражнении 28, может также применяться к вычислению квадрата формального ряда. В соответствии с этим принципом написать алгоритм, который допускает на входе последовательность коэффициентов исходного формального ряда и который вычисляет по мере этого чтения коэффициенты квадрата этого же ряда.
Можно заметить, что этот способ вычисления (волной) является фундаментальным для тех, кто хочет действовать с формальными рядами, т.е. по сути, с бесконечными объектами.
\textbf{b.} Рассмотрим формальный ряд А = \sum \textit{a_{i} X^{i}}, n-ую степень которого
хотим вычислить. Дифференцируя А^{n}, найти формулу, связывающую А и В = А^{n}. Вывести из нее алгоритм, позволяющий вычислить коэффициент одночлена степени i из В, зная i первых коэффициентов ряда А и i — 1 первых коэффициентов В = А^{n}.
c. Применить оба предыдущих алгоритма к случаю многочленов. Какие улучшения это может принести? Какую получаем сложность?

\textbf{34. Определение нулей многочлена по модулю p^{\alpha} }

Целью этого упражнения является разработка алгоритма, позволяющего вычислить для простого числа р нули многочлена в \mathbb{Z} / p^{n} \mathbb{Z} , если они известны в \mathbb{Z} / p \mathbb{Z}

\textbf{a.} Этот вопрос слегка предвосхищает главу II, но разработанный алгоритм необходим для решения следующих вопросов. Указать алгоритм решения уравнения ах = b по модулю n в общем случае.
\textbf{b.} Доказать, что произведение n целых последовательных чисел является кратным n!.
\textbf{c.} Показать, что если а и t — целые числа, Р — многочлен с целыми коэффициентами и \alpha \in \mathbb{N} , то P(a + tp^{\alpha}) \equiv P(a) + tp^{\alpha} P'(a) (mod p^{\alpha + 1}). Отсюда вывести, что если а есть корень Р по модулю p^{\alpha}, то P(a + tp^{\alpha}) \equiv 0 (mod p^{\alpha + 1}) тогда и только тогда, когда P(a)/p^{\alpha} \equiv 0 (mod p). Построить алгоритм, который по известным корням Р по модулю p^{\alpha} определяет их по модулю p^{\alpha + 1}.
\textbf{d.} Пусть а является нулем Р по модулю р таким, что P'(a) \neq 0 (mod p). Вывести из предыдущего вопроса, что существует один и только один нуль Р по модулю (), который был бы сравним с а по модулю p^{i}. Если a^{i} обозначает этот нуль, показать, что a_{i+1} = a_{i} - P(a_{i})P'(a)^{-1} (mod p^{i+1}), формулу, в которой P'(a)^{-1} обозначает обратный к многочлену Р(а) по модулю р.
\textbf{e.} Можно усилить свойство, доказанное в Ь, и показать, что P(a + tp^{\alpha}) \equiv P(a) + tp^{\alpha}P'(a) (mod p^{2\alpha}). С учетом этого свойства, каким становится результат, заявленный по поводу определения корней? Дать новый алгоритм, способный вычислять корни по модулю p^{2n} многочлена, зная его корни по модулю p^{n}.
\textbf{f.} Какой синтез двух алгоритмов может быть сделан?

\textbf{35. Циклическая перестановка элементов массива}

В этом упражнении n представляет собой целое, строго положительное число, которое будет предполагаться заранее определенным.

\textbf{a.} Вспомнить алгоритм, который по заданному массиву, индексированному целыми числами от 0 до n — 1, осуществляет круговую перестановку элементов массива по одному шагу вправо (т.е. элемент с индексом 0 оказывается в ячейке 1, элемент с индексом 1 в ячейке 2... и элемент с индексом n — 1 в ячейке 0).
\textbf{b.} Рассматривается аддитивная группа G = \mathbb{Z} / n\mathbb{Z}  целых по модулю n и а — элемент из G. Каков порядок подгруппы Н группы G, порожденной элементом а? Ответ зависит от n и от а.
Показать, что целый полуоткрытый интервал [0, НОД(n,а)[ является системой представителей G/H. Отсюда вывести, что если х и у — два различных элемента этого последнего интервала, то множества {x + ka| k \in \mathbb{Z}} и {y + ka| k \in \mathbb{Z}} не пересекаются.
\textbf{c.} Вывести отсюда алгоритм, обобщающий алгоритм вопроса а следующим образом: он осуществляет циклическую перестановку таблицы на р шагов вправо, где р — целое число, заданное в алгоритме.
Очевидно, требуемое решение не состоит в применении р раз алгоритма из вопроса а.
Сколько присваиваний элементов массива осуществляется этим алгоритмом? Сравнить это число с числом присваиваний, которое получилось бы при повторении р раз алгоритма из вопроса а.
\textbf{d.} Написать алгоритм, который в массиве меняет местами две группы членов, расположенных соответственно в начале массива и его конце и ограниченных индексом k.
\textbf{e.} Написать Ада-программу, реализуя алгоритм вопроса с и проводя (в случае необходимости) все этапы счета. Программа должна быть в высшей степени модульной (разделить чтение параметров, фиксирование промежуточных результатов и процедуру циклической перестановки). Можно будет протестировать эту программу, используя массивы целых чисел, автоматически заполненных целыми числами от 0 до n — 1; можно предусмотреть отдельную процедуру для такой инициализации.

\textbf{36. Элементарные операции в арифметике повышенной точности}

Располагая фиксированным раз и навсегда основанием для вычислений, которое обозначается b (например, b = 2 или b = 10, или же степенью одного из этих чисел), рассмотрим положительные числа и, заданные их представлением по основанию b:

u = (u_{m}u_{m-1} ... u_{1}u_{0})_{b} = u_{m}b^{m} + u_{m-1}b^{m-1} + ... + u_{1}b + u_{0}

Для всех искомых алгоритмов имеем в своем распоряжении только элементарные арифметические операции над цифрами по основанию b.

\textbf{a.} Написать алгоритм, позволяющий складывать два целых u = (u_{m} ... u_{0})_{b} и v = (v_{m} ... v_{0})_{b}.
\textbf{b.} Написать алгоритм, позволяющий вычислить u — v, если и предполагается большим или равным v.
Если больше не предполагать, что u \geqslant v, модифицировать алгоритм таким образом, чтобы он мог сразу вычислять (u — v) mod b^{m+1} и реализовывать проверку (u < v).
\textbf{c.} Написать алгоритм, позволяющий умножать число u = (u_{m} ... u_{0})_{b} веса \leqslant m на цифру v, т.е. v < b, имея результатом число w = (w_{m+1} ... W_{0})_{b} веса \leqslant m+1
\textbf{d.} Написать алгоритм, позволяющий вычислять остаток и частное от деления числа u = (u_{m} ... u_{0})_{b} веса \leqslant m на цифру v.

\textbf{37. Деление в арифметике повышенной точности}

Показать, что деление каких либо двух чисел всегда сводится обычным делением вручную к следующей общей ситуации:

*делимое имеет цифру большую, чем делитель,
*отношение делимого к делителю является цифрой, т.е. строго меньше, чем основание

Более строго, зададимся двумя числами u = (u_{m+1}u_{m} ... u_{1}u_{0})_{b}, v = (v_{m} ... v_{1}v_{0})_{b} и предположим, что умеем вычислять их частное [u/v], если они удовлетворяют следующим условиям:

u = (u_{m}u_{m-1} ... u_{1}u_{0})_{b}, v = (v_{m} ... v_{1}v_{0})_{b}, u/v < b.

(Это означает, что [u/v] есть цифра). Написать алгоритм, позволяющий определять цифры по основанию b частного q = [u/v] и остатка r = u mod v при делении u на v.

\textbf{38. Вычисление частного методом проб и ошибок}

Чтобы закончить разработку алгоритма деления каких-либо двух чисел, остается только установить способ деления двух чисел u, v, удовлетворяющих условиям (5) упражнения 37.
Идея этого метода (см. Кнут [99]) состоит в действии с помощью метода проб и ошибок: используя критерии, изучаемые ниже, определяют кандидата в частные \widehat{q} \geqslant q = [u/v], затем вычисляют u — \widehat{q}v; эта величина должна удовлетворять условию: u — \widehat{q}v < v. Если это не так, меняют \widehat{q} (пробуя \widehat{q}-1, затем \widehat{q}-2, ...). Теперь вопросы: как определить кандидата в частное наиболее экономным возможным способом и как его менять? Для этого примененный метод использует две наибольшие цифры чисел u и v.

\textbf{a.} Рассмотрим как первоначальную оценку величины q = [u/v] частное от деления двух первых цифр числа и на первую цифру числа v, точнее:

\widehat{q} = min \lgroup \lfloor \frac{u_{m+1}b+u_{m}}{u_{m}} \rfloor , b - 1\rgroup .

Как в этой формуле определить простым способом наименьшее из двух чисел? Показать, что q \leqslant \widehat{q} \leqslant q + (b + v_{m} - 1)/(v_{m} + 1). Что нужно предполагать при реализации, использующей эту оценку?
\textbf{b.} В этом вопросе предполагается, что v имеет более одной цифры, т.е. m \geqslant 1. Для некоторого данного целого числа () >= 0 положим () = (), что можно рассматривать как остаток от деления (). Показать, что

\textit{(i)} \widehat{q}v_{m-1} > b\widehat{r} + u_{m-1} \Longrightarrow q \leqslant \widehat{q} - 1
\textit{(ii)} \widehat{q}v_{m-1} \leqslant b\widehat{r} + u_{m-1} \Longrightarrow q \geqslant \widehat{q} - 1

Вывести из этого и предыдущего вопросов быстрый корректирующий тест, дающий оценку \widehat{q} величины q, удовлетворяющую соотношению q = \widehat{q} или же q = \widehat{q} — 1; будем говорить тогда о скорректированной оценке. Какова выгода от этого теста по сравнению с тестом u — \widehat{q}v < v? Дать примеры, в которых скорректированная оценка отлична от точного частного.
\textbf{c.} Написать алгоритм деления и на v, используя оценку из вопроса а и быстрый тест корректировки из вопроса b.

\textbf{39. Деление: операция нормализации}

Сохраняем обозначения упражнений 37 и 38; в вопросах а и b располагаем двумя числами и, v, удовлетворяющими предположениям (5).

\textbf{a.} Вывести из упражнения 38, вопрос а, что предположение 0 v_{m} \geqslant \lfloor b/2 \rfloor -1 влечет за собой vm \geqslant \lfloor b/2 \rfloor -1\leqslant \widehat{q} - q \leqslant 2.
\textbf{b.} Предположим, что v имеет более одной цифры (m \geqslant 1), v_{m} \geqslant \lfloor b/2 \rfloor и что скорректированная оценка \widehat{q} отлична от q = [u/r]. Показать, что остаток r = u — qv от деления u на v удовлетворяет условию r/v > (1 — 2/b) (можно интерпретировать этот результат, говоря, что вероятность для \widehat{q} быть отличным от q меньше 2/b).
\textbf{c.} Теперь рассмотрим два произвольных целых u = (u_{n} ... u_{0})_{b} и v = (v_{m} ... v_{0})_{b}. Доказать, что если положить d = [b/(v_{m} + 1)], u' = du, v' = dv, то v'm \geqslant [b/2]. Какова связь между делением u на v и делением u' на v'? Каков вес u' и v'? Написать общий алгоритм деления u на v.

\textbf{40. Самовоспроизводящаяся программа}

Во всяком достаточно мощном языке программирования (фактически, который имеет мощность машины Тьюринга) возможно написать программу, единственной целью которой было бы воспроизведение своего текста. Написать такую программу на языке Ада. Указание: прочитать главу о самовоспроизведении у Хофпггадтера [88] или статью Томсона [170].


\textbf{Решения упражнений}


\textbf{1. Вычисление целого квадратного корня}

Подлинная трудность этого упражнения кроется в возможном смешении целого частного от евклидова деления двух целых чисел и рационального числа, определяемого делением этих чисел: а/b = [a/b] + (a mod b)/b. Результат упражнения состоит в том, что последовательность (a_{n}) всегда дает квадратный корень целого числа а, а последующее исследование имеет целью показать, каковы условия сходимости этой последовательности.

\textbf{а.} Целый квадратный корень из а есть целое х такое, что x^{2} \leqslant a <  (x + 1)^{2}. Учитывая неравенство [y/2] \geqslant у/2 — 1/2, справедливое для целого у, можно написать:

\lfloor \frac{x + \lfloor a/x\rfloor }{2} \rfloor \geqslant \frac{x + \lfloor a/x\rfloor }{2} - \frac{1}{2} > \frac{x + a/x - 1}{2} - \frac{1}{2} = \frac{x + a/x}{2} - 1,

и отсюда выводится доказываемый результат. Конечно, начальная форма более эффективна для вычисления.

\textbf{с.} Функция F, соответствующая методу Ньютона, является строго возрастающей в интервале (\sqrt{a}, + \infty ), удовлетворяет условию х > F(x) на открытом интервале и F(a) = \sqrt{a}. Предполагаем впредь, что число а отлично от 0 и 1. Если это не так, легко видеть, что последовательность (a_{n}) постоянна и тогда ее сходимость очевидна. Исследование, проведенное с помощью программ, показывает, что последовательность (a_{n}) является строго убывающей, поскольку к квадратному корню приближаемся сверху. Если предположить a_{n}^{2} > a, имеем a_{n} > \lfloor \sqrt{a} \rfloor, что влечет a_{n} > F(a_{n}) \geqslant \lfloor F(a_{n}) \rfloor = a_{n+1}. Последовательность
целых положительных чисел a_{n} является, следовательно, строго убывающей, пока a_{n}^{2} > a; но это не может длиться бесконечно: существует целое р такое, что a^{2}_{p-1} > a и a^{2}_{p} \leqslant a. Тогда имеем a_{p+1} \geqslant a_{p} - свойство, которое мы будем использовать для построения одного из алгоритмов. Упражнение показывает, и это легко можно доказать, что последовательность (a_{n}) является постоянной или периодической, начиная с номера р: интуитивно a_{p} есть искомый квадратный корень.
\textbf{d.} Покажем, что если a^{2}_{n-1} > a, то (a_{n} + 1)^{2} > a (свойство, которое, будучи примененным к n = р, докажет, что ар является целым квадратным корнем из а). Имеем a_{n} = \lfloor F(a_{n-1}) \rfloor > F(a_{n-1}) - 1 и, следовательно, a_{n} + 1 \geqslant F(a_{n-1}). Но по предположению a_{n-1} > \sqrt{a}, и, значит, F(a_{n-1}) > \sqrt{a}, поскольку функция F строго возрастающая.

\begin{table}
  \caption{}
  \label{tab:}

  \begin{center}
    \begin{tabular}{cc}
      x \longleftarrow x_{0}; x^{2}_{0} \geqslant a & x \longleftarrow x_{0};\\
      \textbf{while} x \times x > a \textbf{loop} & \textbf{loop}\\
      x \longleftarrow \lfloor \frac{x + \lfloor a/x \rfloor }{2} \rfloor ; & x' \longleftarrow \lfloor \frac{x + \lfloor a/x \rfloor }{2} \rfloor ;\\
     \textbf{end loop} ; & \textbf{exit when} x' \geqslant x; \\
     \textbf{return x}; & \textbf{end loop}; \\
       & \textbf{return x}; \\
    \end{tabular}
  \end{center}
\end{table}
\textbf{Вычисление целого квадратного корня}

Ранее было установлено, что a^{2}_{p} \leqslant a < (a_{p} + 1)^{2}. Поэтому получаем: последовательность (a_{n}) обладает строго убывающим начальным сегментом, все члены которого, кроме последнего (с индексом р), строго больше а; этот последний член является целым квадратным корнем из а. Это приводит нас к указанным выше двум алгоритмам. Выбор первоначальной величины последовательности совершенно произвольный. Во втором алгоритме проверка завершения модифицирована, чтобы избежать в ней ненужных перемножений, правда ценой одного дополнительного деления. Сложность этого алгоритма, конечно, ниже сложности алгоритма в действительных числах, потому что убывание последовательности происходит быстрее (по причине целых частных). При выборе первоначального члена последовательности таким, что x^{2}_{0} > a (если x^{2}_{0} = a, то последовательность постоянна), можно доказать следующие свойства:

* последовательность (a_{n}) строго периодична тогда и только тогда, когда a + 1 является полным квадратом; в этом случае период имеет длину 2 и размах колебаний равен 1.
* последовательность стационарна \textbf{тогда и только тогда, когда} a + 1 не является полным квадратом.

\textbf{е.} Основной результат изучения этой новой последовательности состоит в том, что она стабилизируется на \lfloor \sqrt{a} \rfloor или на \lfloor \sqrt{a} \rfloor + 1.

\textbf{Замечание.} Только что изученный алгоритм полностью пригоден для вычисления целого квадратного корня из действительного числа.

\textbf{2. Целая часть функций}

\textbf{a.} Если х — целое число, результат тривиален. Предположим, что x\notin \mathbb{N} . Имеем |x| < х, что влечет f(|x|) \leqslant f(x) и, следовательно, |f(|x|)| \leqslant |f(x)| < f(x) (поскольку х — не целое, f(x) — и подавно). Предположим, что |f(|x|)| < |f(x)|, тогда имеем:

|f(|x|)| < |f(|x|)| + 1 \leqslant |f(x)| < f(x),
и значит f(|x|) \leqslant |f(|x|)| + 1 \leqslant |f(x)| < f(x).

Тогда можно применить теорему о промежуточных значениях в интервале ||x|, х| к величине |f(x)|, и найдем у в этом интервале, удовлетворяющий f(у) = |f(x)|. В соответствии с предположениями относительно f имеем y \in \mathbb{N} и, следовательно, у = |x|. Снова обращаясь к последней строчке неравенств, получаем f(y) \leqslant f(y) + 1 \leqslant f(у), что дает нужное противоречие. Следовательно, |f(|x|)| = |f(x)|.

\textbf{b.} Рассмотрев несколько примеров, быстро замечаем, что обе величины различаются, когда целая часть (меньшая) от х является квадратом. Действительно, легко показать, что |\sqrt{|x|}| \neq |\sqrt{x}| тогда и только тогда, когда m^{2} < x < m^{2} + 1 для целого m. Другими словами, можно утверждать, что |\sqrt{|x|}| = |\sqrt{x}| тогда и только тогда, когда х является целым числом, или же \sqrt{|x|} не является целым.
c. Положим у = |f(x)|. Имеем у \leqslant  f(x) < у + 1, и поскольку f строго возрастает, она обратима и f^{-1}(y) \leqslant x < f^{-1}(y + 1). Итак, по предположению относительно f, f^{-1} принимает целые значения от целых, и значит, f^{-1}(y) < x + 1 \leqslant f^{-1}(y + 1), и применяя f, находим у \leqslant f(x+1) < у + 1, что и доказывает требуемое соотношение.

\textbf{Замечание}
Свойство функций f, изученных в вопросах а и с, в действительности эквивалентно тому факту, что функция, обратная (когда она существует) к этим функциям, принимает целые значения для целых аргументов. Например, это случай функций x \longrightarrow log_{10}x или x \longrightarrow \sqrt{x/2}..., что доказывает в итоге, что такие функции весьма распространены.

\textbf{3. Вычисление целого корня n-й степени}

Функция F строго возрастает на интервале (^{n}\sqrt{a}, \infty ) и удовлетворяет х > F(x) на открытом интервале, а также F(^{n}\sqrt{a}) = ^{n}\sqrt{a}. Если x_{i} > |^{n}\sqrt{a}|, то x_{i} > ^{n}\sqrt{a} (так как x_{i} \in \mathbb{N} ) и значит, x_{i} > F(x_{i}) \geqslant |F(x_{i})| = x_{i+1}. Следовательно, поскольку x_{i} > |^{n}\sqrt{a}|, последовательность x_{i} является строго убывающей. Тогда существует номер р \geqslant 1 такой, что x_{p} \leqslant |^{n}\sqrt{a}| < x_{p-1}.
Теперь покажем, что только предположение x_{i} > |^{n}\sqrt{a}| влечет x_{i+1} + 1 > |^{n}\sqrt{a}|. Имеем x_{i+1} = |F(x_{i})| > F(x_{i}) - 1, т.е. x_{i+1} > F(x_{i}). Но x_{i} > |^{n}\sqrt{a}| и, значит, F(x_{i}) > |^{n}\sqrt{a}|, что и дает результат. Применяя его к i = р — 1, получим x_{p} \leqslant |^{n}\sqrt{a}| < x_{p} + 1; x_{p} является, следовательно, целой частью искомого корня n-й степени.
Нужно особо позаботиться о величине начального члена x_{0}: он должен быть больше, чем |^{n}\sqrt{a}| и, конечно, можно выбрать () (исключая случаи а = 0 или а = 1), но предпочтительнее из-за члена x_{0} = a, участвующего в вычислении x_{i}, взять его как можно меньшим. Можно, например, вычислить целое l такое, что 2^{l} \geqslant a, потом взять x0 = 2^{[l/n]} (что можно также представить в виде 2^{[(l+n-1)/n]}, учитывая тот факт, что немногие машины располагают операцией нахождения верхней целой части).

\textbf{4. Вычисление десятичных знаков числа \sqrt{2}}

Имеем A_{0} = 1, R_{0} = 1 и, конечно, A_{k+1} = 10A_{k} + a_{k+1}; отсюда выводим, что:

R_{k+1} = 2\ldotp 10^{2}_{k+2} - 100A^{2}_{k} - 20a_{k+1}A_{k} - a^{2}_{k+1} = 100R_{k} - (20a_{k+1}A_{k} + a^{2}_{k+1}).

Так как R_{k+1} должно быть наименьшим положительным целым числом, удовлетворяющим данному ему определению, R_{k} может рассматриваться как \textit{остаток} в смысле \textit{«backward error analysis»}, т.е. как сознательно допущенная ошибка.

\begin{table}
  \caption{}
  \label{tab:}

  \begin{center}
    \begin{tabular}{cc}
       \textbf{\underline{A. Первоначальный алгоритм}} & \textbf{\underline{В. Оптимизированный алгоритм}}\\
       & \\
       \textbf{A = A_{k}, R = R_{k}} & \textbf{A = A_{k}, R = R_{k}} \\
       a \longleftarrow 0; R \longleftarrow 100R; & a \longleftarrow 0; R \longleftarrow 100R; \\
       \textbf{while} R \geqslant 20aA + a^{2} \textbf{loop} & \textbf{loop} \\
       a \longleftarrow a + 1; & b := 20A + 2a + 1; \\
       \textbf{end loop}; & \textbf{exit when} R < b; \\
       R \longleftarrow R - (20aA + a^{2}); & R \longleftarrow R - b; \\
       A \longleftarrow 10A + a; & a \longleftarrow a + 1; \\
       a = a_{k+1}, R = R_{k+1}, A = A_{k+1} & \textbf{end loop}; \\
        & A \longleftarrow 10A + a; \\
        & a = a_{k+1}, R = R_{k+1}, A = A_{k+1} \\
    \end{tabular}
  \end{center}
\end{table}
\textbf{Алгоритм 4.} Вычисление десятичных знаков

Объясняем: R_{k} не является ошибкой по отношению к \sqrt{2}, но оно позволяет определить число, для которого A_{k}10^{-k} является точным квадратным корнем; это число есть 2 - R_{k}10^{-2k}.
Как следствие, является наибольшей цифрой числа а, такой что 100R_{k} - (20aA_{k} + a^{2}) положительно. Тогда получаем алгоритм 4-А, прямо используя эти результаты; этот алгоритм вычисляет a_{k+1}, A_{k+1} и R_{k+1}, исходя из a_{k}, A_{k}, и R_{k}. Достаточно повторить k раз алгоритм, начиная с А = 1 и R = 1, для вычисления k первых десятичных знаков \sqrt{2}.
Замечая, что сумма n первых нечетных чисел есть n^{2}, можно легко оптимизировать алгоритм (алгоритм 4-В).
Можно записать 10^{k}\sqrt{2} = A_{k} + \varepsilon c 0 < \varepsilon < 1 (неравенства строгие, потому что \sqrt{2} не имеет конечного десятичного разложения), что позволяет оценить R_{k}:

R_{k} = 2 \ldotp 10^{2k} - A^{2}_{k} = 2 \ldotp 10^{2k} - (10^{k}\sqrt{2} - \varepsilon )^{2} = 2 \ldotp 10^{k} \varepsilon \sqrt{2} - \varepsilon ^{2} = \varepsilon (2A_{k} + \varepsilon ) < 2A_{k} + 1,

следовательно, R_{k} - тоже неограниченное целое число. Предложенный алгоритм легко реализовать на языке формальных вычислений (который содержит неограниченные целые числа), но можно также и на более традиционном языке — операции над большими числами ограничиваются сложением, вычитанием, умножением на 10 (сдвиг на один десятичный знак) и умножением на 2.

\textbf{5. Точный корень из целого числа}

\textbf{a.} Целое число n, разложенное в произведение простых: n = p_{1}^{\alpha_{1}} ... p_{k}^{\alpha_{k}}, является k-й степенью тогда и только тогда, когда k | \alpha_{i} для 1 \leqslant i \leqslant s или когда k делит НОД чисел \alpha_{i}. Из этого выводим, что е(n) = НОД(\alpha_{i}) и что n является k-й степенью тогда и только тогда, когда k | е(n). Отсюда удобно получить: e(n^{q}) = qe(n), что позволяет вычислять e(n^{q}), если известно е(n) (корень r — один и тот же для n и n^{q}).
\textbf{b.} Идея алгоритма 5 следующая: вычисляем n_{1} = \sqrt{\sqrt{...\sqrt{n}}}; поскольку результат — целый, это позволяет записать n = n^{2e_{1}}_{1}, что дает e(n) = 2^{e_{1}}e(n_{1}). Продолжаем с n_{1}, вычисляя n_{2} = \sqrt{\sqrt{...\sqrt{n_{1}}}}, что дает соотношение n1 = n^{3e_{2}}_{2}, откуда e(n) = 2^{e_{1}}3^{e_{2}}e(n_{2}), и подвергают n_{2} такому же преобразованию, \sqrt{\sqrt{...\sqrt{n_{2}}}} и так далее.
Чтобы подтвердить конечность метода, нужно определить для целого r, когда е(r) = 1. Ясно, что е(r) = 1 тогда и только тогда, когда для всякого простого q ^{q}\sqrt{r} \notin \mathbb{N} ; но если r < 2^{q}, всегда имeем ^{q}\sqrt{r} \notin \mathbb{N}. Следовательно, имеем e(r) = 1 Тогда и только тогда, когда ^{q}\sqrt{r} \notin \mathbb{N} для всякого простого q \leqslant \lfloor log_{2}r \rfloor .

e \longleftarrow 1; r \longleftarrow n; p \longleftarrow 2
\textbf{while} p \leqslant \lfloor log_{2}r \rfloor \textbf{loop}
r4 = n, p - простое, ^{q}\sqrt{r} \notin \mathbb{N}, q - простое < p
i \longleftarrow 0
\textbf{loop} r^{ep^{i}} = n
r' \longleftarrow ^{p}\sqrt{r}
exit when r^{lp} \neq r
r \longleftarrow r'; i \longleftarrow i + 1
\textbf{end loop}
e \longleftarrow ep^{i}; p \longleftarrow \textit{Next_Prime(p)}
\textbf{end loop}
re = n, ^{e}\sqrt{r} \notin \mathbb{N}, q - простое \leqslant log_{(2)}r, значит e(r) = 1
return (r, e)
\textbf{Алгоритм 5.} Вычисление корня из целого числа

В цикле этого алгоритма изменяются две величины: простое р возрастает и \textit{остаток} r целого n убывает. При выходе из цикла имеем r^{e} = n, и ни для какого простого q \leqslant \lfloor log_{2}r \rfloor число r не является корнем q-й степени; как следствие, в соответствии с выводами предыдущего абзаца e(r) = 1.
Все числа из интервала [0, 2^{1009}] могут быть \textit{уменьшены} этим алгоритмом с использованием только простых чисел, меньших 1000. Конечно, можно применить алгоритм к числам, расположенным вне этого интервала, но тогда получаемый с помощью алгоритма результат крайне ненадежен при отсутствии дополнительной информации по рассматриваемому числу.

\textbf{6. Порождение простых чисел}

\textbf{а.} Для этого алгоритма используем таблицу целых чисел, которая содержит все уже вычисленные простые числа и которая возникает по мере вычислений. Что касается доказательства корректности этого алгоритма, то можно удовлетвориться рассмотрением того, что происходит в самом внутреннем цикле, который проверяет \textit{Candidate} на простоту.
В этом тесте (алгоритм 6) просматривается последовательность уже вычисленных простых чисел и делается остановка, как только квадрат одного из них превосходит \textit{Candidate}: действительно, в произведении двух нетривиальных множителей один из них меньше квадратного корня из этого числа (обычный критерий остановки решета Эратосфена).
Если обнаруживается простое число, которое делит \textit{Candidate}, то последний объявляется непростым, и цепочка циклов делает переход к проверке следующего нечетного числа. Зато, если \textit{Candidate} преодолевает все простые числа, то он — простое число; в этом случае выходят из цикла Searching-For-Next-Prrme, как только выполнено условие p^{2}i > Candidate в силу предыдущего замечания; найденное простое число помещается в таблицу.

p_{1} \longleftarrow 3; \textit{Candidate} \longleftarrow 3;
\textbf{for k in} 2 .. n \textbf{loop}
\textit{Searching_For_Next_Prime: }\textbf{loop}
\textit{Candidate} \longleftarrow \textit{Candidate} + 2; i \longleftarrow 1
\textbf{loop}
\textbf{exit} \textit{Searching_For_Next_Prime:} when p^{2}_{i} > \textit{Candidate}
\textbf{exit when} \textit{Candidate} mod p_{i} = 0;
i \longleftarrow i + 1;
\textbf{end loop};
\textbf{end loop} \textit{Searching_For_Next_Prime};
p^{k} \longleftarrow \textit{Candidate};
\textbf{end loop};
\textbf{Алгоритм 6.} Генерация простых чисел

Несмотря на все аргументы здравого смысла, которые позволили провести неформальное доказательство этого алгоритма, это доказательство неполно. Действительно, условие остановки p^{2}_{i} > \textit{Candidate} имеет смысл, только если отныне и впредь в таблице имеется простое число, удовлетворяющее этому неравенству. Можно избежать этой проблемы, заменяя условие выхода из цикла \textit{Searching_For_Next_Prime} на

\textbf{exit} \textit{Searching_For_Next_Prime} \textbf{when} i \geqslant  k or else p^{2}_{i} > \textit{Candidate}

В этом случае применяется \textit{чистый} аргумент Эратосфена. Но в действительности эта модификация бесполезна, так как постулат Бертрана говорит нам, что такое р_{i} уже вычислено. Почему? Ответ находится во втором вопросе, с другими оптимизациями, но здесь нужно немного поразмышлять...
\textbf{Ь.} Обратимся к переменной \textit{Ord}, которая определяет номер наименьшего простого числа, квадрат которого превосходит \textit{Candidate} и вторую переменную \textit{Square}, которая имеет значение этого квадрата. Когда нужно менять эти переменные? Когда кандидат превосходит \textit{Square!} Это означает, что \textit{Candidate} \geqslant p^{2}_Ord}, а поскольку задействованные числа — нечетные, в действительности имеем равенство. Итак, непосредственным следствием постулата Бертрана является соотношение p_{i+1} < p^{2}_{i} (что попутно доказывает корректность алгоритма а). Следовательно, когда величина первого кандидата достигает p^{2}_Ord}, имеем уже вычисленным p_{Ord} + 1, и изменение переменных \textit{Square} и \textit{Ord} возможно. Кроме того, поскольку кандидат является квадратом простого числа, он — непростое число. Это приводит нас к модификации (алгоритм 7) метода из вопроса а.

p\textit{1} \longleftarrow 3; \textit{Candidate} \longleftarrow 3; \textit{Square} \longleftarrow 9; \textit{Ord} \longleftarrow 1;
\textbf{for} k in 2 .. n \textbf{loop}
\textit{Searching_For_Next_Prime}: \textbf{loop}
\textit{Candidate} \longleftarrow \textit{Candidate} + 2;
\textbf{if} \textit{Candidate} = \textit{Square} \textbf{then}
\textit{Ord} \longleftarrow \textit{Ord} + 1; \textit{Square} \longleftarrow p^{2}_Ord};
\textit{Candidate} \longleftarrow \textit{Candidate} + 2;
\textbf{end if;}
i \longleftarrow 1;
\textbf{\textbf{loop}
exit} \textit{Searching_For_Next_Prime} when i > \textit{Ord}
\textit{Candidate} < \textit{Square} = p^{2}_Ord} \times i \leqslant \textit{Ord};
\textbf{exit when} \textit{Candidate} mod p_{i} = 0;
i \longleftarrow i + 1;
\textbf{end loop};
\textbf{end loop} \textit{Searching_For_Next_Prime};
p_{k} \longleftarrow \textit{Candidate}
\textbf{end loop};
\textbf{Алгоритм 7.} Генерация простых чисел (оптимизация)

Окончательный алгоритм — с несколькими дополнительными оптимизациями — был, кажется, представлен впервые Далом, Дейкстрой и Хоаром [58]; его можно найти также у Кнута [101] и Верса [182]. В заключение заметим, что для нас постулат Бертрана является теперь теоремой.
